
//input 
// n quantos vertices m quantas arestas e k é quantos portais  
// as proximas n linhas descrevem as coordenadas de cada clareira em um plano 
// as m linhas possuem dois inteiros u e v indicando que existe uma trilha entre duas clareiras que só pode ser percorrida 
// começando em u e terminando em v 
// as proximas k linhas possuem dois inteiros u e v indicando que existe una trilha quais clareiras são conectadas por portais
// a ultima linha contem um numero racional s indicando o numero de energia e um q inficando quantos portais podem ser utilizados 

// a é o vertice de onde tá partindo a aresta 
//b é o vertice de onde tá chegando essa aresta 
// w é o peso 


int n, m, k;

    // n quantos vertices 
    for (int i = 0; i < n; ++i) {
       add_aresta  
    }

    
    // Ler m arestas 
    for (int i = 0; i < m; ++i) {
    }

    // Ler k portais (arestas de peso zero)
    for (int i = 0; i < k; ++i) {
    }

    // Ler energia e quantidade de portais que podem ser utilizados
    double energia;
    int q;
    cin >> energia >> q;

    // Para teste: Imprimir o grafo
    for (int i = 0; i < n; ++i) {
        cout << "Clareira " << i + 1 << ": ";
        Aresta* temp = grp.adj[i].head;
        while (temp) {
            cout << "(" << temp->destino + 1 << ", " << temp->peso << ") ";
            temp = temp->prox;
        }
        cout << endl;
    }

    add_aresta( grp, 0, 5, 3);
    // print(grp[0][5]) // 3
    for(int i=0; i < m; i++){
        int a, b, peso;
        cin >> a >> b >> peso;
        add_aresta(grp, a, b, peso);
    }

    vector<int> clareiras(q); 
    for(int &i : clareiras){
        cin >> i; 
    }


    typedef pair<int, int> Edge; 
    typedef vector<vector<Edge>>Graph 